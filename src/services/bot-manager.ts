import { Deployment } from '../models/deployment';
import { ENV } from '../environment';
import {Health} from "../external-api/bots/health";

interface DeployedInstances {
	latestBuild: Deployment[];
	previousBuilds: Deployment[];
}

export class BotManager {

	private static currentDeploymentId: string; 				// Random string generated by AWS for deployment folder is S3
	private static deployInstances: DeployedInstances = {		// Crypto bot instance public DNS strings
		latestBuild: [],											// List of public DNS for current / latest build
		previousBuilds: []											// DNS for old builds get moved here from latestBuild array if new build is deployed
	};
	private static healthInterval: NodeJS.Timeout;

	public static SetCurrentDeploymentId = (deploymentId: string): string => BotManager.currentDeploymentId = deploymentId;
	public static SetLatestBuilds = (builds: Deployment[]): void => {
		if (BotManager.deployInstances.latestBuild.length) return;
		BotManager.deployInstances.latestBuild = builds;
	}
	public static SetPreviousBuilds = (builds: Deployment[]): void => {
		if (BotManager.deployInstances.previousBuilds.length) return;
		BotManager.deployInstances.previousBuilds = builds;
	}
	public static GetAllBuilds = (): DeployedInstances => BotManager.deployInstances;

	public static RegisterNewBuild = (deploymentId: string, newInstanceDNS: string): void => {
		BotManager.currentDeploymentId = deploymentId;
		BotManager.deployInstances.previousBuilds = [
			...BotManager.deployInstances.previousBuilds,
			...BotManager.deployInstances.latestBuild
		];
		BotManager.deployInstances.latestBuild = [ new Deployment(newInstanceDNS, BotManager.currentDeploymentId) ];
	}

	public static CreateTradeBot = (botId: string): void => {
		const deployment: Deployment = BotManager.GetDeploymentWithMostBots();
		if (deployment) deployment.AddNewBot(botId);
		else console.error('NO DEPLOYMENTS LEFT')
	}

	private static GetDeploymentWithMostBots = (): Deployment => { // Return the deployment with most bots less than limit
		return BotManager.deployInstances.latestBuild.sort((a: Deployment, b: Deployment) => {
			if (a.botCount < b.botCount) return 1;
			if (a.botCount > b.botCount) return -1;
			return 0;
		}).filter((d: Deployment) => d.botCount < ENV.BOT_PER_INSTANCE_LIMIT)[0];
	}

	public static MonitorInstancesHealth = (): void => {
		BotManager.healthInterval = setInterval(() => {
			console.log(BotManager.deployInstances)
			BotManager.deployInstances.latestBuild.forEach(async (deployment: Deployment) => {
				try {
					const response: { success: boolean } = await Health.HealthCheck(deployment.dns);
					if (response.success) return console.log(`Deployment ${deployment.dns} is Healthy`);
					console.error(`Error response from deployment ${deployment.dns} - NOT Healthy`);
				} catch (e) {
					console.error(`Error response from deployment ${deployment.dns} - NOT Healthy`);
				}
			});
			BotManager.deployInstances.previousBuilds.forEach(async (deployment: Deployment) => {
				try {
					const response: { success: boolean } = await Health.HealthCheck(deployment.dns);
					if (response.success) return console.log(`Deployment ${deployment.dns} is Healthy`);
					console.error(`Error response from deployment ${deployment.dns} - NOT Healthy`);
				} catch (e) {
					console.error(`Error response from deployment ${deployment.dns} - NOT Healthy`);
				}
			});
		}, 10000);
	}

	public static StopBotManager = (): void => {
		clearInterval(BotManager.healthInterval);
	}

}
